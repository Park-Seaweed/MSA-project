## 👏 프로젝트 소개

### <노티드>는 온라인으로 도너츠를 판매합니다.
### 웹사이트를 통해서 주문 버튼을 누르는 것으로 구매(Sales API)가 가능합니다.
### 창고에 재고가 있다면 재고가 감소하고 구매가 완료됩니다.
### 유명 유튜버가 도넛-스테이츠의 도너츠가 맛있다고 영상을 올렸습니다.
### 그를 따르는 데브옵스 수강생들이 몰려듭니다. 주문이 급등합니다.
### 창고에 재고가 없기 때문에 구매가 불가능한 경우가 발생합니다.
### 창고의 도너츠 재고가 다 떨어지면 제조 공장에 알려서 다시 창고를 채우는 시스템을 구축해야합니다.
### 제조 공장인 <노티드 팩토리>에 주문을 요청(Leagcy Factory API)할 수 있습니다.
### 주문이 요청되면 일정 시간이 지난 후 창고에 재고가 증가합니다.


<br>
<br>
<br>
<br>



<br>
<br>



## 서비스 아키텍쳐

![MSA](https://user-images.githubusercontent.com/106081707/222883840-ac237ceb-4224-40c9-96df-e3d10491f2ef.png)

<br>
<br>
<br>


<details>
    <summary><strong>💡 클라이언트의 요구 사항</strong></summary>


    - 요구사항 1 : 재고부족으로 인한 구매실패에 대한 조치
      Sales API 를 통해 요청을 받은 서버가 데이터베이스에서 재고 상황을 확인합니다.
      재고가 있다면 감소시키고 응답으로 판매완료 내용을 전달합니다.
      재고가 없는 경우 공장에 주문을 진행합니다
      재고가 없다는 내용을 담은 메세지 페이로드가 주제별로 생성됩니다.
      메세지가 느슨하게 연결된 시스템을 통해 처리될 수 있도록 따로 보관됩니다.

    - 요구사항 2 : 메세지 누락 상황에 대한 조치
      빈번한 요청으로 메세지 누락이 발생합니다.
      메세지가 처리되지 않은 경우 메세지들을 체계적으로 관리할 다른 처리 공간을 생성해야합니다.
      메시지 처리 보관 리소스와 처리되지 않은 메세지 처리 리소스가 연결되어야합니다.

    - 요구사항 3 : Legacy 시스템(Factory → Warehouse) 성능문제에 대한 조치
      안정적으로 이벤트가 전달 될 수 있는 시스템을 구축해야합니다.
      메세지를 소비하는 리소스를 통해 Factory API가 호출됩니다.
      수신된 메세지에 의해 트리거가 된 컴퓨팅 리소스가 상품 재고를 증가시킵니다.
</details>
<br>

<details>
    <summary><strong>💡 SNS와 SQS를 쓰는 이유</strong></summary>


    Amazon SNS (Simple Notification Service)과 Amazon SQS (Simple Queue Service)는 AWS에서 제공하는 서비스로, 둘 다 분산 시스템에서 메시지를 전송하고 처리하는 데 사용됩니다.

    SNS는 메시지를 발행하고, 구독자에게 해당 메시지를 전송하는 역할을 합니다. 반면에 SQS는 메시지를 수신하고 처리하기 위해 대기열에 저장하는 역할을 합니다. 따라서 SNS는 특정 이벤트가 발생했을 때 다른 시스템에 이를 통지하기 위해 사용되고, SQS는 이러한 이벤트에 대한 메시지를 처리하고 응용 프로그램에서 해당 이벤트에 대한 작업을 수행할 수 있도록 지원합니다.

    SNS와 SQS를 함께 사용하는 이유는 다음과 같습니다.

    - 확장성: SNS 및 SQS는 모두 AWS의 분산 아키텍처를 기반으로 하여 확장성이 뛰어나므로 대규모 메시지 처리를 지원할 수 있습니다.

    - 탄력성: SNS 및 SQS를 함께 사용하면 이벤트 처리 및 메시지 처리의 실패 시스템의 탄력성이 향상됩니다. 예를 들어, SQS 대기열에서 메시지를 처리하는 응용 프로그램이 다운되는 경우 SNS는 다른 처리 응용 프로그램으로 메시지를 라우팅하여 처리를 계속할 수 있습니다.

    - 비동기 처리: SNS와 SQS는 모두 비동기 메시지 처리를 지원합니다. 이는 애플리케이션에서 데이터베이스 또는 외부 서비스와 같은 다른 작업을 처리하는 동안 이벤트 및 메시지를 대기열에 보내고 처리할 수 있다는 것을 의미합니다.

    따라서, SNS와 SQS를 함께 사용하면 이벤트 및 메시지 처리를 더욱 효율적으로 처리할 수 있으며, 탄력성과 확장성이 뛰어난 분산 시스템을 구성할 수 있습니다.
</details>
<br>
<details>
    <summary><strong>💡 박민혁 회고</strong></summary>


    ![스크린샷 2023-02-22 오전 9 41 13](https://user-images.githubusercontent.com/106081707/220491149-f7579136-1cf2-4b70-8881-46a0f0b5c296.png)
    처음에 이부분에서 그림과같은 코드가아닌 JSON.parse(event.Records[0].body.MessageAttributes) 이런식으로 했더니 
    ![스크린샷 2023-02-22 오전 9 47 12](https://user-images.githubusercontent.com/106081707/220491906-89e276dd-3c52-4135-b51d-c405e4f59c7b.png)
    아래와 같은 에러가 발생했었습니다... 생각을 해보니까 이미 body값을 파싱했는데  내부 데이터를 다시 파싱하려니까 생겼던 문제였습니다 그래서 위와 같은 코드로 바꾸니 문제 해결 
    다이어그램을 만들어 놓고 제대로 설명하지를 못함..
    ![project3](https://user-images.githubusercontent.com/106081707/220493687-bb2f5644-8191-49b5-a1f0-4983e63647bd.png)
    다이어그램을 확인해보면 sns에서 3개의 sqs 대기열이 존재하는데 운영팀은 sns를 따로 만들어서 sqs대기열을 추가해줘야했었다 운영팀은 전번적인 정보들을 받아야하는데 sales람다에서 이벤트로 넘어가는게 제고가 0일때 넘어가는거여서 아닐 때도 넘어가게 만들었어야했다 그런점을 생각하지 못하고 하나의 sns로 처리할려했다... 이문제에서 느낀점으로는 람다가 의미없이 불리면 안된다는 생각을 갖게되었음... 또한 FIFO로만 구성하려했는데 본질적으로 "왜" 사용해야하는가를 몰랐다 FIFO의 장점은 알고있었다 선입선출이기때문에 순서의 보장이 된다.. 근데 어느상황에 이 방식이 필요한지를 몰랐다.. 그러므로 리소스를 사용할땐 정확한 근거와 스스로 정확하게 이해하고 사용하는게 좋을거같았다

    제고를 100개 채워 놓고 for문으로 돌린놈이 접니다... 그래서 cpu사용률이 올라가서 공장이 무너졌던...
</details>


